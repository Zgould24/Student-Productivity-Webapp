import { OnChanges, SimpleChanges, OnDestroy, EventEmitter, OnInit, SimpleChange, ChangeDetectorRef, TemplateRef, NgZone } from '@angular/core';
import { CountdownConfig, CountdownEvent, CountdownItem } from './interfaces';
import { CountdownTimer } from './countdown.timer';
import { CountdownGlobalConfig } from './countdown.config';
import * as i0 from "@angular/core";
export declare class CountdownComponent implements OnInit, OnChanges, OnDestroy {
    private locale;
    private timer;
    private defCog;
    private cdr;
    private ngZone;
    private frequency;
    private _notify;
    private status;
    private isDestroy;
    private _config;
    i: CountdownItem;
    left: number;
    set config(i: CountdownConfig);
    get config(): CountdownConfig;
    render: TemplateRef<void>;
    readonly event: EventEmitter<CountdownEvent>;
    constructor(locale: string, timer: CountdownTimer, defCog: CountdownGlobalConfig, cdr: ChangeDetectorRef, ngZone: NgZone);
    /**
     * Start countdown, you must manually call when `demand: false`
     */
    begin(): void;
    /**
     * Restart countdown
     */
    restart(): void;
    /**
     * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover
     */
    stop(): void;
    /**
     * Pause countdown, you can use `resume` to recover again
     */
    pause(): void;
    /**
     * Resume countdown
     */
    resume(): void;
    private callEvent;
    private init;
    private destroy;
    /**
     * 更新时钟
     */
    private reflow;
    /**
     * 获取倒计时剩余帧数
     */
    private getLeft;
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngOnChanges(changes: {
        [P in keyof this]?: SimpleChange;
    } & SimpleChanges): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CountdownComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CountdownComponent, "countdown", never, { "config": "config"; "render": "render"; }, { "event": "event"; }, never, never>;
}
